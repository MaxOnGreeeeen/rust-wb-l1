struct Example(i32);

impl Drop for Example {
    fn drop(&mut self) {
        println!("{}", self.0);
    }
}

struct ExampleWrap(Example);

impl Drop for ExampleWrap {
    fn drop(&mut self) {
        let e = std::mem::replace(&mut self.0, Example(0));
        println!("wrap {}", e.0);
    }
}

// Вывод программы:
// 1
// 4
// 5
// 6
// wrap 8
// 8
// 0
// 3
// 2
fn main() {
    // Объект создаётся, но нигде не используется, т.е сразу выходит из области видимости
    // Вызывается деструктор и выводится: 1
    Example(1);

    // Создание переменной, которая живёт до конца исполнения функции
    let _e2 = Example(2);

    // Создание переменной, которая живёт до конца исполнения функции
    let _e3 = Example(3);

    // Объект создаётся, но нигде не используется, т.е сразу выходит из области видимости
    // Вызывается деструктор и выводится: 4
    let _ = Example(4);

    let mut _e5;

    _e5 = Some(Example(5));

    // После присвоения None, так владение объектом Example(5) прекращено, вызывается деструктор
    // Выводится: 5
    _e5 = None;

    let e6 = Example(6);

    // Ручной вызов деструктора
    // Выводится: 6
    drop(e6);

    let e7 = Example(7);

    // Вызов  std::mem::forget предотрвращает вызов деструктора для Example(7)
    std::mem::forget(e7);

    // ExampleWrap нигде не используется, т.е сразу выходит из области видимости
    // Поочередный вызов drop сначала для ExampleWrap: вывод в консоль wrap 8
    // Example(8) после вызова drop вышло за область видимости, происходит вызов деструктора: вывод в консоль 8
    // После вызова деструктора ExampleWrap происходит вызов деструктора для вложенной структуры, в которой было заменено значение: вывод в консоль 0
    ExampleWrap(Example(8));
}
// Выход из области видимости и вызов деструкторов переменных в обратном порядке
// (в обратном порядке попадания в стек) _e3: Вывод в консоль 3
// _e2: Вывод в консоль 2
